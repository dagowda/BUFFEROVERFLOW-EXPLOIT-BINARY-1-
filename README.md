# BUFFEROVERFLOW-EXPLOIT-BINARY-1
#This write-up provides a detailed account of exploiting a buffer overflow vulnerability in a binary file, including identifying the vulnerable code, demonstrating overwriting the return pointer, and gaining execution of shellcode.

Introduction
 In this write-up, I will demonstrate how to exploit a buffer overflow vulnerability in a simple custom binary file using a sample program.

Requirements
To follow along with this write-up, you will need:

A Linux system
Basic knowledge of debugging and exploitation techniques
GDB or GDB with PWN Debugger
Pwndbg extension for Kali(recommended) 
Steps
Identifying the Vulnerable Code
The first step is to download the binary file and copy it into a virtual machine. Then, run the program using GDB or GDB with PWN Debugger. The next step is to display all the functions to determine which function contains the vulnerable code.

Upon reviewing the functions, copyData, checkPassword, and mainframeComputing functions raised the flag. I disassembled all the functions and found that the mainframeComputing function contained the gets function, which took the password input after choosing the third option.

Overwriting the Return Pointer
In the checkPassword function, the buffer being created was 0x14 or 20 in decimal. So, if the buffer was 20 and old ebp is 4 bytes, which makes it 24. Anything more than 24 would overflow the return address. To test this, we ran the program and inputted 24 characters('A'), and saw where the EIP was. It was at the address 0xffffd05c. We then ran the "i frame" command to see at which address the EIP was, and it was at the ebp.

Both the EIP address and the value in the address have not yet been overrun, but the previous address, which is the ebp, is 0x41, which is 'A' in character format. After stepping to the next instruction, the program jumped to the main function. When the input was 25, that was when the return pointer overflowed, and there was a segmentation fault.

I knew the overflow took place after inputting option 3 and then the password, where the offset was 20 and 24, including the ebp.

Gaining Execution of Shellcode
I knew that the shellcode needs to be put in place where the password is inputted, along with the right syntax and NOPs. To obtain the shell, we used a 43-byte long shellcode from shell-storm, which I found by trial and error.

To determine the ESP value after the entire execution, I used the gdb-peda tool and displayed where the jump call happens of the ESP. Any address a little lower than this or an exact address should be fine for the JMPESP to point to in the Python script.

The Python script and the shellcode were then created and tested. I converted the Python script into a text file and ran the command which will be shown in the write up to obtain the shell.
